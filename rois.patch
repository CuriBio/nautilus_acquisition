From 8380295403e09e9163ccbe7779d870e09763225a Mon Sep 17 00:00:00 2001
From: Jason Person <jason.person@curibio.com>
Date: Mon, 8 Apr 2024 10:08:47 -0700
Subject: [PATCH] liveview rois

---
 src/app/src/liveview.cpp | 292 ++++++++++++++++++++++++++++++++++-----
 src/app/src/liveview.h   |  34 ++++-
 2 files changed, 286 insertions(+), 40 deletions(-)

diff --git a/src/app/src/liveview.cpp b/src/app/src/liveview.cpp
index 25874e09..17290ad2 100644
--- a/src/app/src/liveview.cpp
+++ b/src/app/src/liveview.cpp
@@ -49,25 +49,69 @@ std::string fragShader = R"(
 
 layout (location = 0) out vec4 fragColor;
 layout (location = 1) in vec2 texCoord;
+
 layout (binding = 0) uniform R { 
     vec2 iResolution;
+    vec2 iScreen;
     vec2 iLevels;
     vec2 iAuto;
+    vec2 iROIs[4]; // num of rois for 1536 well plate
+    float iNumRois;
 };
+
 uniform sampler2D u_image;
-vec2 fragCoord = gl_FragCoord.xy;
+uniform sampler2D u_rois;
+
+vec4 fragCoord = gl_FragCoord;
+
+float WIDTH = 1023.0;
+float HEIGHT = 1023.0;
+
+float sdRoi(vec2 uv, float size, vec2 offset) {
+    float x = uv.x - offset.x;
+    float y = uv.y - offset.y;
+    return max(abs(x), abs(y)) - size;
+}
 
 void main() {
-    vec2 uv = fragCoord / iResolution.xy;
+    vec2 uv = vec2(fragCoord.x, iResolution.y - fragCoord.y) / iResolution.xy;
+    uv -= 0.5;
+    uv.x *= iResolution.x / iResolution.y;
+
+    vec2 scale = iResolution.xy / vec2(WIDTH, HEIGHT);
+
+    //account for flipped y-axis viewport
+    uv.y += (iScreen.y - iResolution.y) / iResolution.y;
 
     float px = clamp(iAuto.x * (texture(u_image, texCoord).r - iAuto.y), 0.0f, 1.0f);
+    vec4 texColor = vec4(px, px, px, 1.0);
+
     if (px < iLevels.x) {
-        fragColor = vec4(0.0, 0.0, 1.0, 1.0);
+        texColor = vec4(0.0, 0.0, 1.0, 1.0);
     } else if (px >= iLevels.y) {
-        fragColor = vec4(1.0, 0.0, 0.0, 1.0);
-    } else {
-        fragColor = vec4(px, px, px, 1.0);
+        texColor = vec4(1.0, 0.0, 0.0, 1.0);
     }
+
+    //float roi = 0.0;
+    //float res = 0.0;
+    //vec4 col = texColor;
+
+    //int i = 0;
+    //for(i = 0; i < iNumRois; i++) {
+        //roi = sdRoi(uv, 0.1, (iROIs[i].xy * scale.xy) / iResolution.xy);
+        //res = step(0.0, abs(roi) - 0.005);
+        //col = mix(vec4(0.0, 1.0, 0.0, 1.0), col, res);
+    //}
+
+    //fragColor = col;
+    //fragColor = mix(texture(u_rois, texCoord), texColor, 0.5f);
+    //float res = step(0.0, float(texture(u_rois, texCoord).r));
+
+    //fragColor = mix(texColor, vec4(0.0f, 1.0f, 0.0f, 1.0f), res);
+    fragColor = mix(texColor, vec4(0.0f, 1.0f, 0.0f, 1.0f), float(ceil(texture(u_rois, texCoord).r)));
+
+    //fragColor = texture(u_rois, texCoord);
+    //fragColor = texColor;
 })";
 
 /*
@@ -86,6 +130,13 @@ LiveView::LiveView(QWidget* parent, uint32_t width, uint32_t height, bool vflip,
     m_texData = new uint8_t[m_width * m_height * CHANNEL_COUNT];
     memset(m_texData, 255, m_width * m_height * CHANNEL_COUNT);
 
+    float aspect = float(m_width) / float(m_height);
+    int min = std::min(this->size().height(), this->size().width());
+
+    m_roisTex = new uint8_t[m_width * m_height];
+    memset(m_roisTex, 0x00, m_width * m_height);
+    drawFOV_ROIs(32, 4500, 80, 8, 8);
+
     m_backgroundImage = new uint16_t[m_width*m_height];
     for (size_t i = 0; i < m_width*m_height; i++) {
         m_backgroundImage[i] = 0x6000;
@@ -94,6 +145,9 @@ LiveView::LiveView(QWidget* parent, uint32_t width, uint32_t height, bool vflip,
     m_uniforms[0] = m_width;
     m_uniforms[1] = m_height;
 
+    m_shader_uniforms.resolution[0] = m_width;
+    m_shader_uniforms.resolution[1] = m_height;
+
     SetImageFormat(m_imageInFmt);
     setAutoFillBackground(false);
 }
@@ -106,6 +160,53 @@ LiveView::~LiveView() {
 }
 
 
+/*
+ * @brief Draw all ROIs for FOW
+ */
+void LiveView::drawFOV_ROIs(uint32_t roi_size, uint32_t well_spacing, uint8_t scaled_px, uint16_t rows, uint16_t cols) {
+    int32_t well_width_px = (well_spacing / scaled_px);
+    int32_t top_x = m_width / 2 - 0.5*(cols - 1) * well_width_px;
+    int32_t top_y = m_height / 2 - 0.5*(rows - 1) * well_width_px;
+
+    top_x -= m_width / 2;
+    top_y -= m_height / 2;
+    spdlog::info("ROI top_x: {}, top_y: {}", top_x, top_y);
+
+    for (size_t r = 0; r < rows; r++) {
+        int32_t y = top_y + r*well_width_px;
+	for (size_t c = 0; c < cols; c++) {
+	    int32_t x = top_x + c*well_width_px;
+	    spdlog::info("ROI x: {}, y: {}", x, y);
+	    drawROI(x, y, roi_size, 2);
+	}
+    }
+}
+
+/*
+ * @brief Draw ROI
+ */
+void LiveView::drawROI(int32_t x, int32_t y, uint16_t size, uint8_t border) {
+    x -= (m_width / 2);
+    y -= (m_height / 2) - (size / 2);
+
+    auto from_xy = [&](int32_t x, int32_t y) {
+        return x - (size / 2) + (y * m_width);
+    };
+
+    if (!m_roisTex) { return; }
+
+    for (size_t i = 0; i < size; i++) {
+        for (size_t j = 0; j < size; j++) {
+	    if (i < border || i > size-border-1) {
+		memset(m_roisTex+from_xy(x, i-y), 0xFF, size);
+	    } else {
+		memset(m_roisTex+from_xy(x, i - y), 0xFF, border);
+		memset(m_roisTex+from_xy(x + size - border, i - y), 0xFF, border);
+	    }
+	}
+    }
+}
+
 /*
  * @breif Set live view image format.
  *
@@ -157,10 +258,43 @@ void LiveView::UpdateImage(uint16_t* data, float scale, float min) {
     std::unique_lock<std::mutex> lock(m_lock);
     m_uniforms[0] = m_width; //float(this->size().width());
     m_uniforms[1] = m_height; //float(this->size().height());
-    m_uniforms[2] = 0.0f;
-    m_uniforms[3] = float(m_level) / 4095.0f;
-    m_uniforms[4] = scale;
-    m_uniforms[5] = min;
+    m_shader_uniforms.resolution[0] = m_width;
+    m_shader_uniforms.resolution[1] = m_height;
+
+    m_uniforms[2] = float(this->size().width());
+    m_uniforms[3] = float(this->size().height());
+    m_shader_uniforms.screen[0] = float(this->size().width());
+    m_shader_uniforms.screen[1] = float(this->size().height());
+
+    m_uniforms[4] = 0.0f;
+    m_uniforms[5] = float(m_level) / 4095.0f;
+    m_shader_uniforms.levels[0] = 0.0f;
+    m_shader_uniforms.levels[1] = float(m_level) / 4095.0f; //TODO Assumes 12-bit images, will need changed to support 8-bit/16-bit images
+
+    m_uniforms[6] = scale;
+    m_uniforms[7] = min;
+    m_shader_uniforms.autoCon[0] = scale;
+    m_shader_uniforms.autoCon[1] = min;
+
+    m_uniforms[8] = 0;
+    m_uniforms[9] = 0;
+    m_uniforms[10] = 300;
+    m_uniforms[11] = 300;
+    m_uniforms[12] = -300;
+    m_uniforms[13] = -300;
+    m_uniforms[14] = 0;
+    m_uniforms[15] = -300;
+    m_uniforms[16] = 4;
+
+    m_shader_uniforms.rois[0] = 0;
+    m_shader_uniforms.rois[1] = 0;
+    m_shader_uniforms.rois[2] = 300;
+    m_shader_uniforms.rois[3] = 300;
+    m_shader_uniforms.rois[4] = -300;
+    m_shader_uniforms.rois[5] = -300;
+    m_shader_uniforms.rois[6] = 0;
+    m_shader_uniforms.rois[7] = -300;
+    m_shader_uniforms.numRois = 4;
 
     m_imageData = (uint8_t*)(data);
     this->update();
@@ -178,19 +312,33 @@ void LiveView::initializeGL() {
     f->glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
     f->glClear(GL_COLOR_BUFFER_BIT);
 
-    f->glGenTextures(1, &m_texColor);
-    f->glBindTexture(GL_TEXTURE_2D, m_texColor);
+    float aspect = float(m_width) / float(m_height);
+    int min = std::min(this->size().height(), this->size().width());
+    f->glViewport(0, aspect * (this->size().height() - min), min / aspect, min * aspect);
+    int32_t width = (min / aspect);
+    int32_t height = min * aspect;
+
+    float borderColor[] = { 0.5f, 0.5f, 0.5f, 1.0f };
+    f->glGenTextures(2, m_textures);
+
+    f->glActiveTexture(GL_TEXTURE0);
+    f->glBindTexture(GL_TEXTURE_2D, m_textures[0]);
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
     f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
-    float borderColor[] = { 0.5f, 0.5f, 0.5f, 1.0f };
     f->glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
     f->glTexImage2D(GL_TEXTURE_2D, 0, GL_R16, m_width, m_height, 0, GL_RED, GL_UNSIGNED_SHORT, (GLvoid*)0);
-    f->glBindTexture(GL_TEXTURE_2D, 0);
+
+    f->glActiveTexture(GL_TEXTURE1);
+    f->glBindTexture(GL_TEXTURE_2D, m_textures[1]);
+    f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    f->glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, m_width, m_height, 0, GL_RED, GL_UNSIGNED_BYTE, (GLvoid*)m_roisTex);
+
+    spdlog::info("initializeGL - width: {}, height: {}", width, height);
 
     //PBOs
-    spdlog::info("initializeGL - m_width: {}, m_height: {}", m_width, m_height);
     f->glGenBuffers(2, m_pbo);
     f->glBindBuffer(GL_PIXEL_UNPACK_BUFFER, m_pbo[0]);
     f->glBufferData(GL_PIXEL_UNPACK_BUFFER, m_width*m_height*CHANNEL_COUNT, 0, GL_STREAM_DRAW);
@@ -198,9 +346,6 @@ void LiveView::initializeGL() {
     f->glBufferData(GL_PIXEL_UNPACK_BUFFER, m_width*m_height*CHANNEL_COUNT, 0, GL_STREAM_DRAW);
     f->glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
 
-    float aspect = float(m_width) / float(m_height);
-    int min = std::min(this->size().height(), this->size().width());
-    f->glViewport(0, aspect * (this->size().height() - min), min / aspect, min * aspect);
 
     GLint status;
     //vertex shader
@@ -230,8 +375,6 @@ void LiveView::initializeGL() {
     f->glLinkProgram(m_shaderProgram);
     // check for linking errors
 
-    // get texture uniform location
-    m_texLoc = f->glGetUniformLocation(m_shaderProgram, "u_image");
 
     // generate and bind the vao
     fx->glGenVertexArrays(1, &m_vao);
@@ -278,15 +421,40 @@ void LiveView::initializeGL() {
     f->glDeleteShader(m_fragmentShader);
     f->glUseProgram(m_shaderProgram);
 
+    // get texture uniform location
+    f->glUniform1i(f->glGetUniformLocation(m_shaderProgram, "u_image"), 0);
+    f->glUniform1i(f->glGetUniformLocation(m_shaderProgram, "u_rois"), 1);
+
     m_blockIndex = fx->glGetUniformBlockIndex(m_shaderProgram, "R");
     f->glGenBuffers(1, &m_R);
     f->glBindBuffer(GL_UNIFORM_BUFFER, m_R);
     fx->glGetActiveUniformBlockiv(m_shaderProgram, m_blockIndex, GL_UNIFORM_BLOCK_BINDING, &m_binding);
 
-    f->glBufferData(GL_UNIFORM_BUFFER, sizeof(m_uniforms), m_uniforms, GL_DYNAMIC_DRAW);
+    f->glBufferData(GL_UNIFORM_BUFFER, sizeof(m_shader_uniforms), (void*)&m_shader_uniforms, GL_DYNAMIC_DRAW);
     fx->glBindBufferBase(GL_UNIFORM_BUFFER, m_binding, m_R);
 }
 
+void LiveView::resizeGL(int w, int h) {
+    //spdlog::info("resizeGL w: {}, h: {} - m_width: {}, m_height: {}", w, h, m_width, m_height);
+
+    //float aspect = float(m_width) / float(m_height);
+    //int min = std::min(w, h);
+    //int32_t new_width = (min / aspect);
+    //int32_t new_height = min * aspect;
+
+    //delete m_roisTex;
+    //m_roisTex = new uint8_t[new_width * new_height];
+    //memset(m_roisTex, 0x00, new_width * new_height);
+    //drawFOV_ROIs(new_width, new_height, 32, 4500, 80, 8, 8);
+
+    //QOpenGLFunctions *f = QOpenGLContext::currentContext()->functions();
+    //f->glActiveTexture(GL_TEXTURE1);
+    //f->glBindTexture(GL_TEXTURE_2D, m_textures[1]);
+    //f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    //f->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    //f->glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, new_width, new_height, 0, GL_RED, GL_UNSIGNED_BYTE, (GLvoid*)m_roisTex);
+}
+
 /*
  * @breif Draws the pixel data to the screen.
  */
@@ -296,36 +464,82 @@ void LiveView::paintGL() {
     f->glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
     f->glClear(GL_COLOR_BUFFER_BIT);
 
-    f->glUseProgram(m_shaderProgram);
+    float aspect = float(m_width) / float(m_height);
+    int min = std::min(this->size().height(), this->size().width());
+    f->glViewport(0, aspect * (this->size().height() - min), min / aspect, min * aspect);
+    //f->glViewport(0, 0, min / aspect, min * aspect);
+
+    //f->glUseProgram(m_shaderProgram);
 
-    m_uniforms[0] = float(m_width);
-    m_uniforms[1] = float(m_height);
-    m_uniforms[2] = 1.0f / 4095.0f;
-    m_uniforms[3] = float(m_level) / 4095.0f;
+    m_uniforms[0] = float(min / aspect);
+    m_uniforms[1] = float(min * aspect);
+    m_shader_uniforms.resolution[0] = float(min / aspect);
+    m_shader_uniforms.resolution[1] = float(min * aspect);
+
+    m_uniforms[2] = float(this->size().width());
+    m_uniforms[3] = float(this->size().height());
+    m_shader_uniforms.screen[0] = float(this->size().width());
+    m_shader_uniforms.screen[1] = float(this->size().height());
+
+
+    m_uniforms[4] = 1.0f / 4095.0f;
+    m_uniforms[5] = float(m_level) / 4095.0f;
+    //TODO Assumes 12-bit images, will need changed to support 8-bit/16-bit images
+    m_shader_uniforms.levels[0] = 1.0f / 4095.0f;
+    m_shader_uniforms.levels[1] = float(m_level) / 4095.0f;
 
     if (!m_imageData) {
-        m_uniforms[3] = 1.0f;
-        m_uniforms[4] = 1.0f;
-        m_uniforms[5] = 0.0f;
-    }
+        m_uniforms[5] = 1.0f;
+        m_uniforms[6] = 1.0f;
+        m_uniforms[7] = 0.0f;
 
-    float aspect = float(m_width) / float(m_height);
-    int min = std::min(this->size().height(), this->size().width());
-    f->glViewport(0, aspect * (this->size().height() - min), min / aspect, min * aspect);
+	m_shader_uniforms.levels[1] = 1.0f;
+	m_shader_uniforms.autoCon[0] = 1.0f;
+	m_shader_uniforms.autoCon[1] = 0.0f;
+    }
 
-    f->glBufferData(GL_UNIFORM_BUFFER, sizeof(m_uniforms), m_uniforms, GL_DYNAMIC_DRAW);
+    //ROIs
+    m_uniforms[8] = 0;
+    m_uniforms[9] = 0;
+    m_uniforms[10] = 300;
+    m_uniforms[11] = 300;
+    m_uniforms[12] = -300;
+    m_uniforms[13] = -300;
+    m_uniforms[14] = 0;
+    m_uniforms[15] = -300;
+    m_uniforms[16] = 4;
+
+    m_shader_uniforms.rois[0] = 0;
+    m_shader_uniforms.rois[1] = 0;
+    m_shader_uniforms.rois[2] = 300;
+    m_shader_uniforms.rois[3] = 300;
+    m_shader_uniforms.rois[4] = -300;
+    m_shader_uniforms.rois[5] = -300;
+    m_shader_uniforms.rois[6] = 0;
+    m_shader_uniforms.rois[7] = -300;
+    m_shader_uniforms.numRois = 2;
+
+    //spdlog::info("###### iResolution - x: {}, y: {}", m_uniforms[0], m_uniforms[1]);
+
+    f->glBufferData(GL_UNIFORM_BUFFER, sizeof(m_shader_uniforms), (void*)&m_shader_uniforms, GL_DYNAMIC_DRAW);
+    //f->glBufferData(GL_UNIFORM_BUFFER, sizeof(m_uniforms), m_uniforms, GL_DYNAMIC_DRAW);
     fx->glBindBufferBase(GL_UNIFORM_BUFFER, m_binding, m_R);
 
     // bind the texture and PBO
     f->glBindBuffer(GL_PIXEL_UNPACK_BUFFER, m_pbo[m_pboIndex]);
     // copy pixels from PBO to texture object
     // Use offset instead of ponter.
-    f->glBindTexture(GL_TEXTURE_2D, m_texColor);
+    f->glActiveTexture(GL_TEXTURE1);
+    f->glBindTexture(GL_TEXTURE_2D, m_textures[1]);
+
+    f->glActiveTexture(GL_TEXTURE0);
+    f->glBindTexture(GL_TEXTURE_2D, m_textures[0]);
     f->glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, m_width, m_height, GL_RED, GL_UNSIGNED_SHORT, 0);
 
     f->glBindBuffer(GL_PIXEL_UNPACK_BUFFER, m_pbo[1 - m_pboIndex]);
     f->glBufferData(GL_PIXEL_UNPACK_BUFFER, m_width*m_height*CHANNEL_COUNT, 0, GL_STREAM_DRAW);
     GLubyte* ptr = (GLubyte*)fx->glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, m_width*m_height*CHANNEL_COUNT, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
+
     if(ptr) {
         if (m_imageData) { 
             memcpy(ptr, m_imageData, m_width*m_height*CHANNEL_COUNT);
@@ -334,14 +548,18 @@ void LiveView::paintGL() {
         }
         fx->glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);  // release pointer to mapping buffer
     }
+
+    // unbind buffer
     f->glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
-    f->glBindTexture(GL_TEXTURE_2D, m_texColor);
+    f->glActiveTexture(GL_TEXTURE1);
+    f->glBindTexture(GL_TEXTURE_2D, m_textures[1]);
     
     // bind the vao
     fx->glBindVertexArray(m_vao);
     f->glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
 
-    // unbind texture
+    //unbind texture
     f->glBindTexture(GL_TEXTURE_2D, 0);
+
     m_pboIndex = 1 - m_pboIndex;
 }
diff --git a/src/app/src/liveview.h b/src/app/src/liveview.h
index 82a6050e..c67a32f7 100644
--- a/src/app/src/liveview.h
+++ b/src/app/src/liveview.h
@@ -1,4 +1,5 @@
 /*
+ *
  * MIT License
  *
  * Copyright (c) 2022 Curi Bio
@@ -41,8 +42,19 @@
 
 #include <BitmapFormat.h>
 
+#define MAX_ROIS 4
 const int CHANNEL_COUNT = 2;
 
+#pragma pack(1)
+struct ShaderUniforms {
+    float resolution[2];
+    float screen[2];
+    float levels[2];
+    float autoCon[2];
+    float rois[2*MAX_ROIS];
+    float numRois;
+};
+
 /*
  *  LiveView display widget.
  *
@@ -64,9 +76,12 @@ class LiveView : public QOpenGLWidget {
         //QT Overrides
         void initializeGL();
         void paintGL();
+	void resizeGL(int w, int h);
 
     private:
         uint8_t* m_imageData{nullptr};
+	uint8_t* m_roisTex{nullptr};
+
         uint16_t* m_backgroundImage;
         std::mutex m_lock;
 
@@ -83,18 +98,31 @@ class LiveView : public QOpenGLWidget {
         QRectF m_target;
         QImage::Format m_imageOutFmt;
 
-        float m_uniforms[6] = {0, 0, 0.0f, 1.0f, 0.0f, 0.0f};
+        float m_uniforms[17] = {0, 0, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};
+
+	ShaderUniforms m_shader_uniforms = {
+	    .resolution = {0.0f},
+	    .screen = {0.0f},
+	    .levels = {0.0f, 1.0f},
+	    .autoCon = {0.0f},
+	    .rois = {0.0f},
+	    .numRois = 0.0f
+	};
+
         GLuint m_vao, m_vbo, m_ibo;
         unsigned int m_vertexShader, m_fragmentShader, m_shaderProgram;
         uint8_t* m_texData = nullptr;
 
-        GLuint m_blockIndex, m_texColor, m_R;
-        GLint m_binding, m_texLoc;
+	GLuint m_textures[2];
+        GLuint m_blockIndex, m_R;
+        GLint m_binding, m_texLoc, m_roisLoc;
 
         GLuint m_pbo[2];           // IDs of PBOs
         int m_pboIndex{0};
 
         void updatePixels(GLubyte* ptr, size_t len);
+	void drawFOV_ROIs(uint32_t roi_size, uint32_t well_spacing, uint8_t scaled_px, uint16_t rows, uint16_t cols);
+	void drawROI(int32_t x, int32_t y, uint16_t size, uint8_t border);
 };
 
 #endif //LIVEVIEW_H
-- 
2.41.0.windows.2


